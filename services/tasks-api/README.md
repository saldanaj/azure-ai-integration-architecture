# Tasks API (Local Stub)

Small Flask service that exposes the `/patients/{id}/tasks` endpoint used in the demo. It reads from the same SQLite database that the MCP server writes to during local runs.

## Running locally with Docker Compose

The service is already part of the top-level `docker compose` file:

```bash
docker compose up -d --build
```

This builds/starts `mock-fhir`, `mcp-server`, `fhir-listener`, and `tasks-api`, wiring them together via the shared `tasks-data` volume.

## Manual flow verification

1. Trigger the discharge workflow:
   ```bash
   curl -X POST http://localhost:7001/events \
     -H "Content-Type: application/json" \
     --data @events/samples/dischargeCreated.json
   ```
2. Fetch tasks for patient `P123`:
   ```bash
   curl http://localhost:7100/patients/P123/tasks | jq
   ```

You should see the three follow-up items generated by the rule-based extractor.

## Local DB location

During Compose runs the SQLite file lives on the named volume `tasks-data`, mounted at `/data/tasks.db` in both the MCP server and tasks API containers. For direct inspection you can add an extra one-off container:

```bash
docker compose run --rm mcp-server sqlite3 /data/tasks.db 'select * from care_tasks;'
```

(That command requires `sqlite3` inside the image; feel free to install it temporarily if you need deeper inspection.)

## Unit tests

The repoâ€™s stdlib-based test suite covers the extraction heuristics and task-store upsert logic. From the repo root:

```bash
python -m venv .venv
. .venv/bin/activate
python -m unittest discover -s tests
```

No external dependencies are required; everything runs with the standard library.
